// Minimal Supabase Client - Local Fallback
// This provides a basic working supabase client for development
(function(global) {
  'use strict';

  // Simple fetch wrapper for JSON requests
  function jsonRequest(method, url, options = {}) {
    const opts = {
      method,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': options.authorization || '',
        ...options.headers
      },
      ...options
    };
    
    if (opts.body && typeof opts.body === 'object') {
      opts.body = JSON.stringify(opts.body);
    }

    return fetch(url, opts)
      .then(res => {
        console.log(`[Supabase Fetch] ${method} ${url} → ${res.status}`);
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        return res.json();
      })
      .catch(err => {
        console.error(`[Supabase Fetch Error] ${method} ${url}:`, err);
        throw err;
      });
  }

  // Form-encoded request for OAuth2 endpoints
  function formRequest(method, url, options = {}) {
    const opts = {
      method,
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Authorization': options.authorization || '',
        ...(options.headers || {})
      }
    };
    
    // Add body if exists
    if (options.body) {
      if (typeof options.body === 'object') {
        // Convert object to form-encoded string: {email: "a", password: "b"} -> "email=a&password=b"
        opts.body = Object.keys(options.body)
          .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(options.body[key])}`)
          .join('&');
      } else {
        opts.body = options.body;
      }
    }

    console.log('[formRequest] Sending:', { method, url, headers: opts.headers, bodyPreview: opts.body?.substring(0, 50) });

    return fetch(url, opts)
      .then(res => {
        console.log(`[Supabase Fetch] ${method} ${url} → ${res.status}`);
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        return res.json();
      })
      .catch(err => {
        console.error(`[Supabase Fetch Error] ${method} ${url}:`, err);
        throw err;
      });
  }

  // Auth Client
  class SupabaseAuthClient {
    constructor(supabaseClient, apiUrl, authToken) {
      this.supabaseClient = supabaseClient;
      this.apiUrl = apiUrl;
      this.authToken = authToken;
      this._session = null;
      this._user = null;
      this._loadFromStorage();
    }

    _loadFromStorage() {
      try {
        if (typeof localStorage !== 'undefined') {
          // Try to load full session first (for Supabase auth)
          const stored = localStorage.getItem('sb-auth-token');
          if (stored) {
            this._session = JSON.parse(stored);
            // If session doesn't have user object but has access_token, extract email from JWT
            if (this._session?.access_token) {
              // If session has user, use it; otherwise try to decode JWT to get user info
              if (this._session?.user) {
                this._user = this._session.user;
              } else {
                // Try to extract basic info from JWT (limited parsing without validation)
                try {
                  const parts = this._session.access_token.split('.');
                  if (parts.length === 3) {
                    const payload = JSON.parse(atob(parts[1]));
                    this._user = { id: payload.sub, email: payload.email };
                  }
                } catch (e) {
                  console.warn('Could not parse JWT');
                }
              }
            }
          }
          
          // Also try to load user-only storage (for fallback scenarios)
          if (!this._user) {
            const userStored = localStorage.getItem('sb-auth-user');
            if (userStored) {
              this._user = JSON.parse(userStored);
              console.log('[Auth] Usuario recuperado de localStorage:', this._user);
            }
          }
        }
      } catch (e) {
        console.warn('Failed to load auth from storage:', e);
      }
    }

    _saveToStorage() {
      try {
        if (typeof localStorage !== 'undefined' && this._session) {
          localStorage.setItem('sb-auth-token', JSON.stringify(this._session));
        }
      } catch (e) {
        console.warn('Failed to save auth to storage:', e);
      }
    }

    async signUp(email, password) {
      const url = `${this.apiUrl}/auth/v1/signup`;
      try {
        const response = await formRequest('POST', url, {
          body: { email, password },
          headers: { 'apikey': this.authToken }
        });
        
        if (response.user) {
          this._user = response.user;
          if (response.session) {
            this._session = response.session;
            this._saveToStorage();
          }
        }
        return { data: { user: response.user, session: response.session }, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }

    async signInWithPassword(email, password) {
      // Handle both calling styles:
      // 1. signInWithPassword({ email, password })  <- Supabase standard
      // 2. signInWithPassword(email, password)      <- Positional params
      let emailVal, passwordVal;
      
      if (typeof email === 'object' && email !== null && 'email' in email) {
        emailVal = email.email;
        passwordVal = email.password;
      } else {
        emailVal = email;
        passwordVal = password;
      }
      
      const url = `${this.apiUrl}/auth/v1/token?grant_type=password`;
      try {
        console.log('[Auth] signInWithPassword request to:', url);
        console.log('[Auth] credentials:', { email: emailVal, password: passwordVal });
        
        const response = await formRequest('POST', url, {
          body: { email: emailVal, password: passwordVal },
          headers: { 
            'apikey': this.authToken,
            'Content-Type': 'application/x-www-form-urlencoded'
          }
        });
        
        console.log('[Auth] signInWithPassword response:', response);
        
        if (response.access_token) {
          this._session = response;
          // If response has user object, use it; otherwise create minimal user object from response
          if (response.user) {
            this._user = response.user;
          } else {
            // Try to extract user info from JWT
            try {
              const parts = response.access_token.split('.');
              if (parts.length === 3) {
                const payload = JSON.parse(atob(parts[1]));
                this._user = { id: payload.sub, email: payload.email };
              } else {
                this._user = { email: emailVal };
              }
            } catch (e) {
              this._user = { email: emailVal };
            }
          }
          this._saveToStorage();
        }
        return { data: { user: this._user, session: response }, error: null };
      } catch (error) {
        console.error('[Auth] signInWithPassword error:', error);
        return { data: null, error };
      }
    }

    async signOut() {
      this._session = null;
      this._user = null;
      try {
        localStorage.removeItem('sb-auth-token');
      } catch (e) {
        console.warn('Failed to clear storage:', e);
      }
      return { error: null };
    }

    getSession() {
      return { data: { session: this._session }, error: null };
    }

    getUser() {
      return { data: { user: this._user }, error: null };
    }

    // Method to manually set user (for fallback scenarios)
    _setUser(user) {
      this._user = user;
      // Also save user separately so it persists across page loads
      try {
        if (typeof localStorage !== 'undefined' && user) {
          localStorage.setItem('sb-auth-user', JSON.stringify(user));
          console.log('[Auth] Usuario guardado en localStorage:', user);
        }
      } catch (e) {
        console.warn('Failed to save user to storage:', e);
      }
      // Also save a minimal session so getUser() works
      if (user && !this._session) {
        this._session = { user };
        this._saveToStorage();
      }
    }
  }

  // Database Query Builder (simplified)
  class PostgrestQueryBuilder {
    constructor(supabaseClient, table, authToken) {
      this.supabaseClient = supabaseClient;
      this.table = table;
      this.authToken = authToken;
      this._url = null;
      this._filters = [];
      this._select = '*';
      this._orderBy = null;
      this._orderAsc = true;
      this._limitCount = null;
      this._singleMode = false;
      this._promise = null;
    }

    select(columns = '*') {
      this._select = columns;
      return this;
    }

    order(column, options = {}) {
      this._orderBy = column;
      this._orderAsc = options.ascending !== false;
      return this;
    }

    limit(count) {
      this._limitCount = count;
      return this;
    }

    eq(column, value) {
      this._filters.push({ column, operator: 'eq', value });
      return this;
    }

    single() {
      // Set limit to 1 and mark as single mode
      // When executing, will return the single row instead of array
      this._limitCount = 1;
      this._singleMode = true;
      return this;
    }

    _buildUrl() {
      const baseUrl = `${this.supabaseClient.url}/rest/v1/${this.table}`;
      const params = [];
      
      // Add select
      params.push(`select=${encodeURIComponent(this._select)}`);
      
      // Add filters - formato PostgREST: column=operator.value (sin comillas)
      for (const filter of this._filters) {
        let filterValue = filter.value;
        let encodedFilter;
        
        // PostgREST expects: column=operator.value (without quotes, even for UUIDs)
        // The value is already URL-encoded when needed
        if (typeof filterValue === 'string') {
          // For UUID and string values: don't add quotes, just URL-encode if needed
          encodedFilter = `${filter.column}=${filter.operator}.${encodeURIComponent(filterValue)}`;
        } else {
          // Para números: column=operator.value
          encodedFilter = `${filter.column}=${filter.operator}.${filterValue}`;
        }
        params.push(encodedFilter);
      }
      
      // Add order
      if (this._orderBy) {
        const direction = this._orderAsc ? 'asc' : 'desc';
        params.push(`order=${encodeURIComponent(this._orderBy)}.${direction}`);
      }
      
      // Add limit
      if (this._limitCount) {
        params.push(`limit=${this._limitCount}`);
      }
      
      const query = params.length > 0 ? '?' + params.join('&') : '';
      return baseUrl + query;
    }

    _execute() {
      if (this._promise) return this._promise;
      
      this._promise = new Promise((resolve, reject) => {
        const url = this._buildUrl();
        console.log('[Supabase Query] URL:', url); // Debug
        
        jsonRequest('GET', url, {
          headers: { 
            'apikey': this.authToken, 
            'Authorization': this.authToken ? `Bearer ${this.authToken}` : '' 
          }
        })
        .then(response => {
          let data = Array.isArray(response) ? response : (response ? [response] : []);
          
          // In single mode, return the first item or null instead of array
          if (this._singleMode) {
            data = data.length > 0 ? data[0] : null;
          }
          
          console.log('[Supabase Query] Response data count:', Array.isArray(data) ? data.length : (data ? 1 : 0));
          resolve({ data, error: null });
        })
        .catch(error => {
          console.error('[Supabase Query Error]:', error);
          reject({ data: null, error });
        });
      });
      
      return this._promise;
    }

    // Support both promise chains and then() calls
    then(onFulfilled, onRejected) {
      return this._execute().then(onFulfilled, onRejected);
    }

    catch(onRejected) {
      return this._execute().catch(onRejected);
    }

    async get() {
      return await this._execute();
    }

    async insert(record) {
      const url = `${this.supabaseClient.url}/rest/v1/${this.table}`;
      try {
        const response = await jsonRequest('POST', url, {
          body: record,
          headers: { 
            'apikey': this.authToken, 
            'Authorization': this.authToken ? `Bearer ${this.authToken}` : '' 
          }
        });
        return { data: response, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }

    async update(record) {
      const url = `${this.supabaseClient.url}/rest/v1/${this.table}`;
      try {
        const response = await jsonRequest('PATCH', url, {
          body: record,
          headers: { 
            'apikey': this.authToken, 
            'Authorization': this.authToken ? `Bearer ${this.authToken}` : '' 
          }
        });
        return { data: response, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }

    async delete() {
      const url = `${this.supabaseClient.url}/rest/v1/${this.table}`;
      try {
        await jsonRequest('DELETE', url, {
          headers: { 
            'apikey': this.authToken, 
            'Authorization': this.authToken ? `Bearer ${this.authToken}` : '' 
          }
        });
        return { error: null };
      } catch (error) {
        return { error };
      }
    }
  }

  // Database Client
  class SupabaseDatabase {
    constructor(supabaseClient, authToken) {
      this.supabaseClient = supabaseClient;
      this.authToken = authToken;
    }

    from(table) {
      return new PostgrestQueryBuilder(this.supabaseClient, table, this.authToken);
    }

    rpc(functionName, params = {}) {
      const self = this;
      return {
        then: async (callback) => {
          const url = `${this.supabaseClient.url}/rest/v1/rpc/${functionName}`;
          try {
            const response = await jsonRequest('POST', url, {
              body: params,
              headers: { 'apikey': this.authToken, 'Authorization': this.authToken ? `Bearer ${this.authToken}` : '' }
            });
            callback({ data: response, error: null });
          } catch (error) {
            callback({ data: null, error });
          }
        }
      };
    }
  }

  // Main Supabase Client
  class SupabaseClient {
    constructor(options = {}) {
      this.url = options.url || 'https://localhost:3000';
      this.headers = options.headers || {};
      
      const authOptions = options.auth || {};
      this.auth = new SupabaseAuthClient(this, this.url, authOptions.key);
      this.db = new SupabaseDatabase(this, authOptions.key);
      this._anonKey = authOptions.key;
    }

    // Get current auth token (access_token if logged in, else anonKey)
    _getCurrentAuthToken() {
      const session = this.auth._session;
      if (session && session.access_token) {
        return session.access_token;
      }
      return this._anonKey;
    }

    from(table) {
      // Update db's authToken to current token before querying
      this.db.authToken = this._getCurrentAuthToken();
      return this.db.from(table);
    }

    rpc(functionName, params = {}) {
      // Update db's authToken to current token before calling RPC
      this.db.authToken = this._getCurrentAuthToken();
      return this.db.rpc(functionName, params);
    }
  }

  // createClient factory
  function createClient(supabaseUrl, supabaseAnonKey) {
    if (!supabaseUrl) throw new Error('supabaseUrl is required');
    if (!supabaseAnonKey) throw new Error('supabaseAnonKey is required');

    return new SupabaseClient({
      url: supabaseUrl,
      auth: { key: supabaseAnonKey }
    });
  }

  // Export to global scope
  global.supabase = {
    createClient,
    SupabaseClient,
    SupabaseAuthClient,
    PostgrestQueryBuilder,
    SupabaseDatabase
  };

})(typeof window !== 'undefined' ? window : global);
